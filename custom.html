<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Primary Meta Tags -->
    <title>WebGl Gallery - IVIIXIO</title>
    <meta name="title" content="WebGl Gallery - IVIIXIO" />
    <meta
      name="description"
      content="Get started with pixi.js to render 3d Web Experience, Infinite draggable canvas with multiple images. Made by IVIIXIO"
    />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://metatags.io/" />
    <meta property="og:title" content="WebGl Gallery - IVIIXIO" />
    <meta
      property="og:description"
      content="Get started with pixi.js to render 3d Web Experience, Infinite draggable canvas with multiple images. Made by IVIIXIO"
    />
    <meta
      property="og:image"
      content="https://github.com/mohnishlandge/WebGl-Image-Gallery-Showcase/blob/main/webglgall.png"
    />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://metatags.io/" />
    <meta property="twitter:title" content="WebGl Gallery - IVIIXIO" />
    <meta
      property="twitter:description"
      content="Get started with pixi.js to render 3d Web Experience, Infinite draggable canvas with multiple images. Made by IVIIXIO"
    />
    <meta
      property="twitter:image"
      content="https://github.com/mohnishlandge/WebGl-Image-Gallery-Showcase/blob/main/webglgall.png"
    />
    <style>
      @-ms-viewport {
        width: device-width;
      }

      html {
        margin: 0;
        width: 100%;
        height: 100vh;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: black;
        font-family: Arial, Helvetica, sans-serif;
      }

      .view {
        position: absolute;
        filter: grayscale(1);
        transition: 1s ease-in-out;
      }

      .view:active {
        filter: grayscale(0);
      }

      .input {
        position: absolute;
        z-index: 100;
        color: rgb(224, 224, 224);
        font-size: 1.2em;
        margin: 0 auto;
        padding: 1rem 2rem;
        border-radius: 0.2rem;
        background-color: rgba(37, 37, 37, 0.555);
        border: none;
        width: 12em;
        bottom: 3.5em;
        left: 2em;

        border-bottom: 0.3rem solid transparent;
        transition: all 0.3s;
      }

      .button {
        transform-origin: center;
        display: flex;
        justify-content: center;
        position: absolute;
        pointer-events: auto;
        cursor: pointer;
        background: #ffffff;
        border: none;
        padding: 1.5rem 3rem;
        margin: 0;
        font-family: inherit;
        font-size: inherit;
        position: relative;
        z-index: 100;
      }

      .button::before,
      .button::after {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* Made with the help of Amelia Bellamy-Royds' article "Perfecting Paths for <textPath>":
      https://oreillymedia.github.io/Using_SVG/extras/ch07-textpaths.html */

      .button--surtur {
        position: absolute;
        padding: 0;
        background: none;
        -webkit-clip-path: circle(40% at 50% 50%);
        clip-path: circle(40% at 50% 50%);
      }

      .button--surtur:focus-visible {
        background: #443ffc;
      }

      .textcircle {
        position: relative;
        display: block;
        width: 200px;
      }

      .textcircle text {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 32px;
        text-transform: uppercase;
        fill: rgb(255, 255, 255);
      }

      .textcircle textPath {
        letter-spacing: 17px;
        /* Firefox needs this */
      }

      .button--surtur:hover .textcircle {
        animation: rotateIt 7s linear infinite;
      }

      .eye {
        position: absolute;
        z-index: 2;
        width: 60px;
        height: 60px;
        top: calc(50% - 30px);
        left: calc(50% - 30px);
      }

      .eye__outer,
      .eye__inner,
      .eye__lashes-up,
      .eye__lashes-down {
        stroke: rgb(255, 255, 255);
        fill: none;
        stroke-width: 1.5px;
      }

      .eye__lashes-down {
        opacity: 0;
      }

      .button--surtur:hover .eye__lashes-up,
      .button--surtur:hover .eye__inner,
      .button--surtur:hover .eye__iris {
        animation: blinkHide 2s step-end infinite;
      }

      .button--surtur:hover .eye__lashes-down {
        animation: blinkShow 2s step-end infinite;
      }

      @keyframes blinkHide {
        0% {
          opacity: 0;
        }

        10% {
          opacity: 1;
        }
      }

      @keyframes blinkShow {
        0% {
          opacity: 1;
        }

        10% {
          opacity: 0;
        }
      }

      .unsplash {
        position: absolute;
        margin: 0%;
        right: 5em;
        bottom: 5em;
      }

      .refresh {
        position: absolute;
        margin: 0%;
        left: 22em;
        bottom: 5em;
      }

      .share {
        position: absolute;
        margin: 0%;
        left: 25em;
        bottom: 5em;
      }

      button {
        background: transparent;
        border: none;
        cursor: pointer;
      }
      h3 {
        position: absolute;
        z-index: 100;
        color: rgb(73, 73, 73);
        font-size: 0.8em;
        margin: 0 auto;
        padding: 1rem 2rem;
        border-radius: 0.2rem;
        border: none;
        bottom: 1.5em;
        left: 0.8em;

        border-bottom: 0.3rem solid transparent;
        transition: all 0.3s;
      }
      b {
        color: rgb(187, 187, 187);
      }
      h2 {
        position: absolute;
        z-index: 100;
        color: rgb(73, 73, 73);
        font-size: 0.8em;
        margin: 0 auto;
        padding: 1rem 2rem;
        border-radius: 0.2rem;
        border: none;
        top: 10em;
        right: -8em;
        transform: rotate(90deg);
        border-bottom: 0.3rem solid transparent;
        transition: all 0.3s;
      }

      .iviixio svg {
        position: absolute;
        z-index: 100;
        margin: 0 auto;
        top: 3em;
        right: 3em;
        width: 5%;
      }
      @media only screen and (max-device-width: 500px) {
        .unsplash {
          position: absolute;
          margin: 0%;
          right: 3em;
          top: 5em;
        }

        .input {
          bottom: 3em;
          left: 2em;
        }

        .share {
          left: 18em;
          bottom: 9em;
        }

        .refresh {
          left: 3em;
          bottom: 9em;
        }
        h3 {
          font-size: 0.7em;
          bottom: 1em;
        }
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.0.2/pixi.min.js"></script>
  </head>

  <body>
    <h2>Made by <b>IVIIXIO / Mohnish Landge</b></h2>
    <div class="iviixio">
      <svg
        id="Layer_1"
        data-name="Layer 1"
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 1152.67 1156.07"
      >
        <defs>
          <style>
            .cls-1 {
              fill: #fff;
            }
          </style>
        </defs>
        <title>IVIIXIO-SVG</title>
        <path
          class="cls-1"
          d="M1533.91,955.92c-2.9,666,11.72,567.31-22.64,575.52-47.73,0-93,0-140.21,0-9.46-1.39-27.14,4.27-30-5-5.57-179.38-.06-361.09-2-541.11-.12-199.9.19-401.51-.14-599.91,3.27-5.29,10-9.39,15.39-5.4,4.77.12,9.2-.2,14.37-.07h71.36c116.1,1.8,91-16.12,93.86,65.19Zm-99.35,508h5.1c12.26,0,17.64-5.36,17.65-17.6q0-10.39,0-20.8,0-478.44,0-956.88a17.1,17.1,0,0,1,.2-4.48c2.09-7.65-4.41-16.49-12.49-16.66-5.33-.12-10.66-.05-16,0-7.7.05-15.59,7.94-15.59,15.56q0,488,.06,975.88c0,4.72,0,9.94,1.94,14C1419.37,1461.38,1426,1466.43,1434.56,1463.93Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M1054.36,1072.15c0,137.4,0,275.49,0,413-.85,13.94,1.8,28.1-1.26,42.25-3.53,7-15.1,3.26-22.43,3.84a318.41,318.41,0,0,0-34,.49c-22.42,2.58-15.29-11.81-14.7-24.7,1.78-1081.84-5.81-900.78,10.13-942.24-13.71-22.46-9.15-43.38-10-64.52-.44-37.91.66-75.42-.63-113.12.2-11.12,13.73-8.93,21.76-8.42,10.37.5,20.12,1,30.53,1,8.13-1.16,23.23.17,20.91,10.22-1,41.21,0,80-.26,120.47,2.42,19,26.72,17.19,39.84,12,9.55-4.85,2.38-16.77,4.09-25.93.81-37.21-1.77-74.43,1.15-110.33,8.56-12.24,13.89-4.55,21.85-5.71,16-.6,32.27-.75,47.46-.41,9.54,8.15,5.33,23.17,6.16,34.78,0,18.85,0,37.16,0,56-1.4,25.14,4.36,81.9-8.51,92.63-9.75,9,10.65,3.88,8.55,41.43-.89,309.38,1.12,611.05-.84,920.74-2.06,8.54-13.71,5.66-21.9,6.1-9.53.06-18.29.47-27.9.62-27.08,1.93-26-6.34-26-27.18-.85-40,.45-78.57,1.63-118.41-3.15-126.35-1.11-252.41-1.61-378.93-1.48-35.26,3.68-70.4.39-105.45,2.37-63.31,1-126,.34-189.23-3-121.22,8.34-118.36-25-117.76-24.9-10-18.72,50.25-19.56,59.32,0,27.91-.07,55.12-.1,83.05Q1054.27,905.06,1054.36,1072.15Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M502.81,929.48V441.75c1.48-64.26-9.09-63.13,28.31-61.63,11.23,0,21.78,0,33.09-.46,10-2.45,12.21,2.78,12.84,18.57,2.27,1107.09-6,1050.11,9.07,1063.33,28.14,8.58,37-3.11,35-27.38,4.38-258.8,1.22-516.88,2.11-775.57-1.34-90,2.55-180-1.55-269.55,0-2.23,1.59-4.36,4-6.82,3.63-4.86,6.81-3.79,12.75-3.56,8.84.79,15.58,1.48,24.72,1.35,13.13,1,33.45-4.9,34.37,11.51-.07,360,.55,721-.66,1080.33-1.4,13.88-7.67,17.83-18.93,24.37-8.94,11.21-18.82,19.83-29.4,28.93-11,9.28-26.84,5.37-40,6.42-16.85-.5-33.57,1.46-49.63-1.76-7.83-2.12-11.55-9.17-17.66-13.93-17.26-11.36-35.09-25-37.81-44.88C501.91,1290.67,503.26,1110,502.81,929.48Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M382.29,1034.54q0-243.19.11-486.38a73.52,73.52,0,0,1,2.53-18.78c1.31-4.92,5.65-4,10.14-3.8,16.48.6,33,.23,49.48.24,8.73,0,12.3,3.5,12.32,12q1,490.14,2.25,980.26c0,7.54-4.47,10.6-9,14.12-1.17.91-4.1-.74-6.23-.75-15.49-.08-31-.16-46.48,0-3.93.06-8.31,3.71-11.23-1.71-1.53-2.84-3.71-5.92-3.71-8.89Q382.18,1277.72,382.29,1034.54Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M807.28,1531.43c-17.16.73-34.13-1.67-51.34,1.26-3.06.41-3.93.72-7-.79-3.53-2.6-8.85-4.53-8.49-8.73,2.31-24.28.29-49.83.93-74.58.06-299.63,0-595.85.16-894.74.54-37.31,6.61-26.53,34.26-28.06,33.16.8,36.95-5.85,41,21.16-5.26,1079,6.79,963.6-8.43,987.28C808.05,1533.3,807.66,1532.37,807.28,1531.43Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M1293.05,1027q0,245,0,489.93c0,3.5,1.34,7.91-.3,10.27-2.33,3.37-5.28,9.31-11.61,4.64-.8-.58-2.27-.36-3.42-.36-13.83,0-27.68-.39-41.49.17-4.81.19-9.71,2.67-12.85-2.83-1.9-3.33-4.42-7.06-4.42-10.62q-.3-484.92-.1-969.85c0-5.65.52-11.61,2.46-16.81,1-2.62,5.65-5.37,8.73-5.46,17.81-.51,35.65-.27,53.48-.24,6.44,0,9.56,3,9.56,9.74q-.09,208.21,0,416.44Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M861.82,1031.06V541.19c0-3.27-1.05-7.19.38-9.64,1.53-2.63,5.37-5.39,8.29-5.48,17.14-.5,34.31-.23,51.47-.25,10.48,0,12.06,1.7,12.08,13.14l2.07,981.15c0,9.62-4,11.92-13.16,11.67-17.52-.49-35.09.93-52.62.57-2.89-.06-6.18-4.82-8.3-8-1.15-1.75-.21-4.87-.21-7.37Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M458.91,413.66c.63,31.7,2,34.54-28.35,34.33-17.35-.9-43.77,7-47.71-9.19a325.19,325.19,0,0,1,.14-50.62c3.33-2.91,5.66-11.11,9.28-9.41C436.27,386.81,463.76,359,458.91,413.66Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M742.07,413.74c-.66-17.86-8.64-37.31,16.16-33.78,17,1,32.33-.45,49.87-.19,8.2,2.31,9.63,7.34,7.78,15.51.35,12.49,1.09,25.7,1.47,38.74-.6,6.22-6.15,15.06-10.41,13.9-19.83-1.21-34.39-1.78-55,.49-6.86-.55-9.63-6.4-11.71-10.09,2.38-8.65.76-16.27,1.18-24.53Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M1218.78,412.77c.36-15.7-3.91-35,16.43-34.6,17.91.45,34.62,2.39,52.46.86,2.47,1.74,4.49,5.58,6.19,7.09-1.12,5-.69,9.88-.81,15-1.49,17.1,4.22,43-5.43,45.6C1219.84,450.43,1216.66,454.46,1218.78,412.77Z"
          transform="translate(-381.93 -378.16)"
        />
        <path
          class="cls-1"
          d="M936.12,413.05c-1.7,11.73,3.49,24.4-3.63,30.91-1.89,1.51-2.46,4.64-4.07,4.44-9.85-1.92-18-.63-27.12-1.2-43.48.6-42.76,5.26-40.31-35.86,1.16-9.39-1.15-19.19,2.59-27.92,6.74-7.86,36.67-1.29,43.67-3.25C944.87,377.13,934.55,384.75,936.12,413.05Z"
          transform="translate(-381.93 -378.16)"
        />
      </svg>
    </div>
    <input
      type="text"
      class="input"
      placeholder="Enter Unsplash Username"
      id="myInput"
    />

    <button
      type="button"
      class="button button--surtur"
      onClick="location.href='index.html';"
    >
      <svg class="textcircle" viewBox="0 0 500 500">
        <title>Infinite WebGL Gallery - IVIIXIO</title>
        <defs>
          <path
            id="textcircle"
            d="M250,400 a150,150 0 0,1 0,-300a150,150 0 0,1 0,300Z"
          />
        </defs>
        <text>
          <textPath
            xlink:href="#textcircle"
            aria-label="Infinite WebGL Gallery - IVIIXIO"
            textLength="900"
          >
            Infinite WebGL Gallery - IVIIXIO
          </textPath>
        </text>
      </svg>
      <svg
        aria-hidden="true"
        class="eye"
        width="70"
        height="70"
        viewBox="0 0 70 70"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          class="eye__outer"
          d="M10.5 35.308c5.227-7.98 14.248-13.252 24.5-13.252s19.273 5.271 24.5 13.252c-5.227 7.98-14.248 13.253-24.5 13.253s-19.273-5.272-24.5-13.253z"
        />
        <path
          class="eye__lashes-up"
          d="M35 8.802v8.836M49.537 11.383l-3.31 8.192M20.522 11.684l3.31 8.192"
        />
        <path
          class="eye__lashes-down"
          d="M35 61.818v-8.836 8.836zM49.537 59.237l-3.31-8.193 3.31 8.193zM20.522 58.936l3.31-8.193-3.31 8.193z"
        />
        <circle class="eye__iris" cx="35" cy="35.31" r="5.221" />
        <circle class="eye__inner" cx="35" cy="35.31" r="10.041" />
      </svg>
    </button>
    <h3>Try <b>"eliapelle"</b> or <b>"mohnishlandge"</b> then press Enter</h3>
    <!-- Main -->
    <canvas class="view" ontouchstart=""></canvas>
    <a href="https://unsplash.com/mohnishlandge" target="_blank"
      ><div class="unsplash">
        <svg width="32" height="32" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M10 9V0h12v9H10zm12 5h10v18H0V14h10v9h12v-9z"
            fill="#fff"
            fill-rule="nonzero"
          />
        </svg>
      </div>
    </a>
    <div class="refresh">
      <button type="button" onClick="window.location.reload();">
        <svg
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <g id="24 / arrows / refresh-ccw">
            <path
              id="icon"
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M10 7H6.19306C7.55354 5.0787 9.60638 4 12 4C16.4183 4 20 7.58172 20 12H22C22 6.47715 17.5228 2 12 2C9.19577 2 6.72511 3.18251 5 5.27035V2H3V9H10V7ZM14 17H17.8069C16.4465 18.9213 14.3936 20 12 20C7.58172 20 4 16.4183 4 12H2C2 17.5228 6.47715 22 12 22C14.8042 22 17.2749 20.8175 19 18.7297V22H21V15H14V17Z"
              fill="white"
            />
          </g>
        </svg>
      </button>
    </div>
    <div class="share">
      <button
        type="button"
        onClick="location.href='https://github.com/mohnishlandge/WebGl-Image-Gallery-Showcase';"
      >
        <svg
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <g id="24 / software / terminal">
            <path
              id="icon"
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3ZM3 19V5H21V19H3ZM8.33333 12L5.4 9.8L6.6 8.2L11.6667 12L6.6 15.8L5.4 14.2L8.33333 12ZM12 14V16H17V14H12Z"
              fill="white"
            />
          </g>
        </svg>
      </button>
    </div>
    <script id="backgroundFragment" type="x-shader/x-fragment">
      // Adapted from: https://www.shadertoy.com/view/MdlGRr

      // It is required to set the float precision for fragment shaders in OpenGL ES
      // More info here: https://stackoverflow.com/a/28540641/4908989
      #ifdef GL_ES
      precision mediump float;
      #endif

      uniform vec2 uPointerDiff;

      // This function returns 1 if `coord` correspond to a grid line, 0 otherwise
      float isGridLine (vec2 coord) {
        vec2 pixelsPerGrid = vec2(50.0, 50.0);
        vec2 gridCoords = fract(coord / pixelsPerGrid);
        vec2 gridPixelCoords = gridCoords * pixelsPerGrid;
        vec2 gridLine = step(gridPixelCoords, vec2(1.0));
        float isGridLine = max(gridLine.x, gridLine.y);
        return isGridLine;
      }

      // Main function
      void main () {
        // Coordinates minus the `uPointerDiff` value, and plus an offset
        vec2 coord = gl_FragCoord.xy - uPointerDiff + vec2(10.0);
        // Set `color` to black
        vec3 color = vec3(0.0);
        // If it is a grid line, change blue channel to 0.3
        color.b = isGridLine(coord) * 0.0;
        // Assing the final rgba color to `gl_FragColor`
        gl_FragColor = vec4(color, 0.0);
      }
    </script>

    <script id="stageFragment" type="x-shader/x-fragment">
      // Adapted from: https://www.shadertoy.com/view/4lSGRw

      #ifdef GL_ES
      precision mediump float;
      #endif

      // Uniforms from Javascript
      uniform vec2 uResolution;
      uniform float uPointerDown;

      // The texture is defined by PixiJS
      varying vec2 vTextureCoord;
      uniform sampler2D uSampler;

      // Function used to get the distortion effect
      vec2 computeUV (vec2 uv, float k, float kcube) {
        vec2 t = uv - 0.5;
        float r2 = t.x * t.x + t.y * t.y;
        float f = 0.0;
        if (kcube == 0.0) {
          f = 1.0 + r2 * k;
        } else {
          f = 1.0 + r2 * (k + kcube * sqrt(r2));
        }
        vec2 nUv = f * t + 0.5;
        nUv.y = 1.0 - nUv.y;
        return nUv;
      }

      void main () {
        // Normalized coordinates
        vec2 uv = gl_FragCoord.xy / uResolution.xy;

        // Settings for the effect
        // Multiplied by `uPointerDown`, a value between 0 and 1
        float k = -0.9 * uPointerDown;
        float kcube = 0.1 * uPointerDown;
        float offset = 0.008 * uPointerDown;

        // Get each channel's color using the texture provided by PixiJS
        // and the `computeUV` function
        float red = texture2D(uSampler, computeUV(uv, k + offset, kcube)).r;
        float green = texture2D(uSampler, computeUV(uv, k, kcube)).g;
        float blue = texture2D(uSampler, computeUV(uv, k - offset, kcube)).b;

        // Assing the final rgba color to `gl_FragColor`
        gl_FragColor = vec4(red, green, blue, 1.0);
      }
    </script>
    <script>
      ;(function () {
        // Class to generate a random masonry layout, using a square grid as base
        class Grid {
          // The constructor receives all the following parameters:
          // - gridSize: The size (width and height) for smallest unit size
          // - gridColumns: Number of columns for the grid (width = gridColumns * gridSize)
          // - gridRows: Number of rows for the grid (height = gridRows * gridSize)
          // - gridMin: Min width and height limits for rectangles (in grid units)
          constructor(gridSize, gridColumns, gridRows, gridMin) {
            this.gridSize = gridSize
            this.gridColumns = gridColumns
            this.gridRows = gridRows
            this.gridMin = gridMin
            this.rects = []
            this.currentRects = [
              { x: 0, y: 0, w: this.gridColumns, h: this.gridRows },
            ]
          }

          // Takes the first rectangle on the list, and divides it in 2 more rectangles if possible
          splitCurrentRect() {
            if (this.currentRects.length) {
              const currentRect = this.currentRects.shift()
              const cutVertical = currentRect.w > currentRect.h
              const cutSide = cutVertical ? currentRect.w : currentRect.h
              const cutSize = cutVertical ? 'w' : 'h'
              const cutAxis = cutVertical ? 'x' : 'y'
              if (cutSide > this.gridMin * 2) {
                const rect1Size = randomInRange(
                  this.gridMin,
                  cutSide - this.gridMin
                )
                const rect1 = Object.assign({}, currentRect, {
                  [cutSize]: rect1Size,
                })
                const rect2 = Object.assign({}, currentRect, {
                  [cutAxis]: currentRect[cutAxis] + rect1Size,
                  [cutSize]: currentRect[cutSize] - rect1Size,
                })
                this.currentRects.push(rect1, rect2)
              } else {
                this.rects.push(currentRect)
                this.splitCurrentRect()
              }
            }
          }

          // Call `splitCurrentRect` until there is no more rectangles on the list
          // Then return the list of rectangles
          generateRects() {
            while (this.currentRects.length) {
              this.splitCurrentRect()
            }
            return this.rects
          }
        }

        // Generate a random integer in the range provided
        function randomInRange(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min
        }

        // Get canvas view
        const view = document.querySelector('.view')
        // Loaded resources will be here
        const resources = PIXI.Loader.shared.resources
        // Target for pointer. If down, value is 1, else value is 0
        let pointerDownTarget = 0
        // Useful variables to keep track of the pointer
        let pointerStart = new PIXI.Point()
        let pointerDiffStart = new PIXI.Point()
        let width, height, app, background, uniforms, diffX, diffY

        // Variables and settings for grid
        const gridSize = 30
        const gridMin = 3
        const imagePadding = 10
        let gridColumnsCount, gridRowsCount, gridColumns, gridRows, grid
        let widthRest, heightRest, centerX, centerY, container, rects
        let images, imagesUrls

        // Set dimensions
        function initDimensions() {
          width = window.innerWidth
          height = window.innerHeight
          diffX = 0
          diffY = 0
        }

        // Set initial values for uniforms
        function initUniforms() {
          uniforms = {
            uResolution: new PIXI.Point(width, height),
            uPointerDiff: new PIXI.Point(),
            uPointerDown: pointerDownTarget,
          }
        }

        // Initialize the random grid layout
        function initGrid() {
          // Getting columns
          gridColumnsCount = Math.ceil(width / gridSize)
          // Getting rows
          gridRowsCount = Math.ceil(height / gridSize)
          // Make the grid 5 times bigger than viewport
          gridColumns = gridColumnsCount * 5
          gridRows = gridRowsCount * 5
          // Create a new Grid instance with our settings
          grid = new Grid(gridSize, gridColumns, gridRows, gridMin)
          // Calculate the center position for the grid in the viewport
          widthRest = Math.ceil(gridColumnsCount * gridSize - width)
          heightRest = Math.ceil(gridRowsCount * gridSize - height)
          centerX =
            (gridColumns * gridSize) / 2 - (gridColumnsCount * gridSize) / 2
          centerY = (gridRows * gridSize) / 2 - (gridRowsCount * gridSize) / 2
          // Generate the list of rects
          rects = grid.generateRects()
          // For the list of images
          images = []
          // For storing the image URL and avoid duplicates
          imagesUrls = {}
        }

        // Init the PixiJS Application
        function initApp() {
          // Create a PixiJS Application, using the view (canvas) provided
          app = new PIXI.Application({ view })
          // Resizes renderer view in CSS pixels to allow for resolutions other than 1
          app.renderer.autoDensity = true
          // Resize the view to match viewport dimensions
          app.renderer.resize(width, height)

          // Set the distortion filter for the entire stage
          const stageFragmentShader =
            document.getElementById('stageFragment').textContent
          const stageFilter = new PIXI.Filter(
            undefined,
            stageFragmentShader,
            uniforms
          )
          app.stage.filters = [stageFilter]
        }

        // Init the gridded background
        function initBackground() {
          // Create a new empty Sprite and define its size
          background = new PIXI.Sprite()
          background.width = width
          background.height = height
          // Get the code for the fragment shader from the loaded resources
          const backgroundFragmentShader =
            document.getElementById('backgroundFragment').textContent
          // Create a new Filter using the fragment shader
          // We don't need a custom vertex shader, so we set it as `undefined`
          const backgroundFilter = new PIXI.Filter(
            undefined,
            backgroundFragmentShader,
            uniforms
          )
          // Assign the filter to the background Sprite
          background.filters = [backgroundFilter]
          // Add the background to the stage
          app.stage.addChild(background)
        }

        // Initialize a Container element for solid rectangles and images
        function initContainer() {
          container = new PIXI.Container()
          app.stage.addChild(container)
        }

        // Load texture for an image, giving its index
        function loadTextureForImage(index) {
          var inputName = document.getElementById('myInput').value
          // Get image Sprite
          const image = images[index]
          // Set the url to get a random image from Unsplash Source, given image dimensions
          const url = `https://source.unsplash.com/user/${inputName}/${image.width}x${image.height}`
          // Get the corresponding rect, to store more data needed (it is a normal Object)
          const rect = rects[index]
          // Create a new AbortController, to abort fetch if needed
          const { signal } = (rect.controller = new AbortController())
          // Fetch the image
          fetch(url, { signal })
            .then((response) => {
              // Get image URL, and if it was downloaded before, load another image
              // Otherwise, save image URL and set the texture
              const id = response.url.split('?')[0]
              if (imagesUrls[id]) {
                loadTextureForImage(index)
              } else {
                imagesUrls[id] = true
                image.texture = PIXI.Texture.from(response.url)
                rect.loaded = true
              }
            })
            .catch(() => {
              // Catch errors silently, for not showing the following error message if it is aborted:
              // AbortError: The operation was aborted.
            })
        }

        // Add solid rectangles and images
        function initRectsAndImages() {
          // Create a new Graphics element to draw solid rectangles
          const graphics = new PIXI.Graphics()
          // Select the color for rectangles
          graphics.beginFill(0x000000)
          // Loop over each rect in the list
          rects.forEach((rect) => {
            // Create a new Sprite element for each image
            const image = new PIXI.Sprite()
            // Set image's position and size
            image.x = rect.x * gridSize
            image.y = rect.y * gridSize
            image.width = rect.w * gridSize - imagePadding
            image.height = rect.h * gridSize - imagePadding
            // Set it's alpha to 0, so it is not visible initially
            image.alpha = 0
            // Add image to the list
            images.push(image)
            // Draw the rectangle
            graphics.drawRect(image.x, image.y, image.width, image.height)
          })
          // Ends the fill action
          graphics.endFill()
          // Add the graphics (with all drawn rects) to the container
          container.addChild(graphics)
          // Add all image's Sprites to the container
          images.forEach((image) => {
            container.addChild(image)
          })
        }

        // Check if rects intersects with the viewport
        // and loads corresponding image
        function checkRectsAndImages() {
          // Loop over rects
          rects.forEach((rect, index) => {
            // Get corresponding image
            const image = images[index]
            // Check if the rect intersects with the viewport
            if (rectIntersectsWithViewport(rect)) {
              // If rect just has been discovered
              // start loading image
              if (!rect.discovered) {
                rect.discovered = true
                loadTextureForImage(index)
              }
              // If image is loaded, increase alpha if possible
              if (rect.loaded && image.alpha < 1) {
                image.alpha += 0.01
              }
            } else {
              // The rect is not intersecting
              // If the rect was discovered before, but the
              // image is not loaded yet, abort the fetch
              if (rect.discovered && !rect.loaded) {
                rect.discovered = false
                rect.controller.abort()
              }
              // Decrease alpha if possible
              if (image.alpha > 0) {
                image.alpha -= 0.01
              }
            }
          })
        }

        // Check if a rect intersects the viewport
        function rectIntersectsWithViewport(rect) {
          return (
            rect.x * gridSize + container.x <= width &&
            0 <= (rect.x + rect.w) * gridSize + container.x &&
            rect.y * gridSize + container.y <= height &&
            0 <= (rect.y + rect.h) * gridSize + container.y
          )
        }

        // Start listening events
        function initEvents() {
          // Make stage interactive, so it can listen to events
          app.stage.interactive = true

          // Pointer & touch events are normalized into
          // the `pointer*` events for handling different events
          app.stage
            .on('pointerdown', onPointerDown)
            .on('pointerup', onPointerUp)
            .on('pointerupoutside', onPointerUp)
            .on('pointermove', onPointerMove)
        }

        // On pointer down, save coordinates and set pointerDownTarget
        function onPointerDown(e) {
          const { x, y } = e.data.global
          pointerDownTarget = 1
          pointerStart.set(x, y)
          pointerDiffStart = uniforms.uPointerDiff.clone()
        }

        // On pointer up, set pointerDownTarget
        function onPointerUp() {
          pointerDownTarget = 0
        }

        // On pointer move, calculate coordinates diff
        function onPointerMove(e) {
          const { x, y } = e.data.global
          if (pointerDownTarget) {
            diffX = pointerDiffStart.x + (x - pointerStart.x)
            diffY = pointerDiffStart.y + (y - pointerStart.y)
            diffX =
              diffX > 0
                ? Math.min(diffX, centerX + imagePadding)
                : Math.max(diffX, -(centerX + widthRest))
            diffY =
              diffY > 0
                ? Math.min(diffY, centerY + imagePadding)
                : Math.max(diffY, -(centerY + heightRest))
          }
        }

        // Init everything
        function init() {
          initDimensions()
          initUniforms()
          initGrid()
          initApp()
          initBackground()
          initContainer()
          initRectsAndImages()
          initEvents()

          // Animation loop
          // Code here will be executed on every animation frame
          app.ticker.add(() => {
            // Multiply the values by a coefficient to get a smooth animation
            uniforms.uPointerDown +=
              (pointerDownTarget - uniforms.uPointerDown) * 0.075
            uniforms.uPointerDiff.x += (diffX - uniforms.uPointerDiff.x) * 0.2
            uniforms.uPointerDiff.y += (diffY - uniforms.uPointerDiff.y) * 0.2
            // Set position for the container
            container.x = uniforms.uPointerDiff.x - centerX
            container.y = uniforms.uPointerDiff.y - centerY
            // Check rects and load/cancel images as needded
            checkRectsAndImages()
          })
        }

        // Clean the current Application
        function clean() {
          // Stop the current animation
          app.ticker.stop()

          // Remove event listeners
          app.stage
            .off('pointerdown', onPointerDown)
            .off('pointerup', onPointerUp)
            .off('pointerupoutside', onPointerUp)
            .off('pointermove', onPointerMove)

          // Abort all fetch calls in progress
          rects.forEach((rect) => {
            if (rect.discovered && !rect.loaded) {
              rect.controller.abort()
            }
          })
        }

        // On resize, reinit the app (clean and init)
        // But first debounce the calls, so we don't call init too often
        let resizeTimer
        function onResize() {
          if (resizeTimer) clearTimeout(resizeTimer)
          resizeTimer = setTimeout(() => {
            clean()
            init()
          }, 200)
        }
        // Listen to resize event
        window.addEventListener('resize', onResize)

        // Init the app
        init()
      })()
    </script>
  </body>
</html>
